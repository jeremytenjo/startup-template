import path from 'path'

import assert from '@useweb/assert'

import type { GetTablesDataTablesProps } from '../getTablesData/getTablesData.js'
import createFile from '../../../../../../../../../devtools/utils/node/createFile.js'
import generateSupabaseDevDatabaseConfig from '../../generateSupabaseDevDatabase.config.js'
import type { DatabaseFunctionSchema } from '../getDatabaseFunctions/getDatabaseFunctions.js'

export type CreateMigrationSqlFileProps = {
  tables: GetTablesDataTablesProps
  functions: DatabaseFunctionSchema[]
}

export default async function createMigrationSqlFile(props: CreateMigrationSqlFileProps) {
  assert<CreateMigrationSqlFileProps>({ props, requiredProps: ['tables'] })
  const migrationFilePath = path.join(
    process.cwd(),
    'supabase/migrations/20230919034526_createCreatorPlatformStatsTable.sql',
  )
  let migrationFileContents = '-- auto generated by generateSupabaseDevDatabase.ts\n'

  // add extensions
  generateSupabaseDevDatabaseConfig.extensions.map((extension) => {
    migrationFileContents += `create extension if not exists ${extension.name} cascade;\n\n`
  })

  // add tables
  const tablesOrderedByGenOrder = props.tables.sort((a, b) => a.genOrder - b.genOrder)

  await Promise.all(
    tablesOrderedByGenOrder.map(async (table) => {
      // fixes ERROR: cannot create a unique index without the column "time" error.
      const dontAddId = table.customTablePropDataType
      const columnProperties = Object.keys(table.schemaProps).filter((p) => p !== 'id')
      let columnSchemasString = ''
      let createHypertable = ''

      if (table.disablePrimaryKeyAutoGeneration) {
        columnProperties.unshift('id')
      }

      columnProperties.map((key, index) => {
        const islastColumn = index === columnProperties.length - 1
        const valueType = table.schemaProps[key]?.type || 'string'

        let dataType =
          key === 'id'
            ? 'text primary key'
            : key.includes('Date')
            ? 'bigint'
            : valueType.includes?.('string')
            ? 'text'
            : valueType.includes('object')
            ? 'jsonb'
            : valueType.includes('number')
            ? 'bigint'
            : valueType.includes('array')
            ? 'jsonb'
            : valueType.includes('boolean')
            ? 'bool'
            : 'text'

        let referencesString = ''
        const references = table.references?.[key]

        if (references) {
          referencesString = references
        }

        if (table.customTablePropDataType?.[key]) {
          dataType = table.customTablePropDataType?.[key]
        }

        // https://docs.timescale.com/api/latest/hypertable/create_hypertable/
        if (table.createHyperTable) {
          createHypertable = `select create_hypertable('"${table.createHyperTable.tableName}"', '${table.createHyperTable.timeProperty}');\n\n`
        }

        columnSchemasString += `"${key}" ${dataType}${
          references ? ` not null references "${referencesString}"` : ''
        }${islastColumn ? '' : ',\n'}`
      })
      migrationFileContents += `create table "${table.name}" (
${
  dontAddId || table.disablePrimaryKeyAutoGeneration
    ? ''
    : '"id" bigint primary key generated always as identity,'
}
${columnSchemasString}
);\n\n`

      migrationFileContents += createHypertable
    }),
  )

  // Add functions
  props.functions.map((func) => {
    migrationFileContents += `${func.fn}\n\n`
  })

  await createFile({
    filePath: migrationFilePath,
    fileContent: migrationFileContents,
    nojs: true,
    overwrite: true,
  })
}

export type CreateMigrationSqlFileReturn = ReturnType<typeof createMigrationSqlFile>

// const getArrayType = (props: { value: any }) => {
//   const type = props.value.items.type.includes('string') ? 'text' : 'text'

//   return {
//     dataType: `${type} array`,
//   }
// }
